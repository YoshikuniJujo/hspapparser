2013.08.20 Tue.

SigP と ViewP は、Type と Exp の parser を書いてからにする。

2013.08.21 Wed.

layout rule で複数の indent をまたぐ場合がうまくいかない。
state に保存しておいて、そこから取り出すことを試してみたが、
これは、失敗したときに問題となると思う。

たとえば、

do hoge
   boke
   do kasu
      tako
   piyo

は、

do {hoge
   ;boke
   ;do {kasu
       ;tako
   };piyo
}

となる必要がある。
しかし、piyo のインデントによって、'}' と ';' の2つのトークンを返さなければならない。
これは LL の範疇で出来ることだろうか?

stmts が indent を返すようにしたらどうだろうか。
新たな行がより残いインデントを返した場合、

exp が indent を返すようにした場合どうなるか。
まず、stmts のところで indent がより浅かったなら、その前で終わる。
これでうまくいきそうだな。

test 環境でやってみようかな。

exp = var

stmts = exp (';' exp)*

} を入れる代わりに、そこで終わると考える。

stmts	= exp &(_, x):lx[x == ...] stmts
	/ exp &(_, x):lx[x < ...]?

space	= ...
	/ \n+ &(_, x):lx[x > ...]


2つ問題がある。
ひとつは、forall の省略が以外に面倒くさそうなのと、
もうひとつは、forall を省略した場合に、pred をつける場合に、
そのままやると EqualP あたりで左再帰になってしまうところだ。

forall の省略は、parser の外でやれば良いのかもしれない。
いや、parser のなかであっても、:: の右に来るときに一回だけ行うというのが良いよう
にも思う。
つまり、forall で宣言されていない、型変数を探して、
それらを含む ForallT をつけてやる、といった感じか。

左再帰の問題はひとつ rule を増やすことで対応可能か。
とりあえず、typInf の上に、typCxt かなんかをつくれば良いだろう。
